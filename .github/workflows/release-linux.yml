name: Create Linux Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g. 1.2.3)'
        required: true
        default: '0.0.0'
      tag:
        description: 'Git tag to create (if empty use v{version})'
        required: false
      unity_version:
        description: 'Unity Editor version to use for CI (e.g. 2021.3.31f1). Required for building MateEngineX.'
        required: false
        default: 'auto'

permissions:
  contents: write

jobs:
  build_and_release:
    name: Build and create release
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up variables
        id: vars
        run: |
          VERSION=${{ github.event.inputs.version }}
          TAG=${{ github.event.inputs.tag }}
          if [ -z "$TAG" ]; then TAG="v${VERSION}"; fi
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "TAG=$TAG" >> $GITHUB_OUTPUT

      - name: Check Unity license secrets
        run: |
          # Ensure we have either UNITY_LICENSE or UNITY_SERIAL+UNITY_EMAIL+UNITY_PASSWORD
          if [ -n "${{ secrets.UNITY_SERIAL }}" ] && [ -n "${{ secrets.UNITY_EMAIL }}" ] && [ -n "${{ secrets.UNITY_PASSWORD }}" ]; then
            echo "UNITY_SERIAL credentials found; will use serial activation."
            exit 0
          fi
          if [ -n "${{ secrets.UNITY_LICENSE }}" ]; then
            echo "UNITY_LICENSE found; will use license file activation."
            exit 0
          fi
          echo "Unity license secrets are missing. Provide either UNITY_LICENSE or UNITY_SERIAL + UNITY_EMAIL + UNITY_PASSWORD."
          exit 1

      - name: Run build
        run: |
          set -e
          if [ -x ./build.sh ]; then
            echo "Running ./build.sh"
            ./build.sh
          elif [ -x ./scripts/build.sh ]; then
            echo "Running ./scripts/build.sh"
            ./scripts/build.sh
          else
            echo "No build script found; skipping build"
          fi

      - name: Build Unity project
        uses: game-ci/unity-builder@v4
        with:
          unityVersion: ${{ github.event.inputs.unity_version }}
          projectPath: .
          targetPlatform: StandaloneLinux64
          buildName: MateEngineX
          buildsPath: build/unity
        env:
          UNITY_LICENSE: ${{ secrets.UNITY_LICENSE }}
          UNITY_SERIAL: ${{ secrets.UNITY_SERIAL }}
          UNITY_EMAIL: ${{ secrets.UNITY_EMAIL }}
          UNITY_PASSWORD: ${{ secrets.UNITY_PASSWORD }}

      - name: Package Unity build artifacts
        id: package_unity
        run: |
          set -e
          BUILD_DIR=build/unity
          if [ -d "$BUILD_DIR" ]; then
            OUT="mate-engine-unity-${{ steps.vars.outputs.VERSION }}.tar.gz"
            echo "Packaging Unity build from $BUILD_DIR -> $OUT"
            tar -C "$BUILD_DIR" -czf "$OUT" .
            ls -lh "$OUT"
            echo "unity_build_artifact=$OUT" >> $GITHUB_OUTPUT
          else
            echo "No Unity build artifacts found in $BUILD_DIR"; exit 2
          fi

      - name: Build plugins package
        run: |
          set -e
          if [ -x ./scripts/build_plugins.sh ]; then
            ./scripts/build_plugins.sh
          else
            echo "No plugins build script found; skipping"
          fi

      - name: Create release tarball
        id: package_release
        run: |
          set -euo pipefail
          OUT_NAME="mate-engine-linux-${{ steps.vars.outputs.VERSION }}.tar.gz"
          echo "Creating release tarball $OUT_NAME containing runtime artifacts and integration plugin"

          TMPDIR=$(mktemp -d)
          echo "Staging in $TMPDIR"

          # If the Unity build artifact exists and looks like a tar, extract it to preserve runtime layout
          if [ -n "${{ steps.package_unity.outputs.unity_build_artifact }}" ] && [ -f "${{ steps.package_unity.outputs.unity_build_artifact }}" ]; then
            UNITY_ART="${{ steps.package_unity.outputs.unity_build_artifact }}"
            echo "Found Unity artifact: $UNITY_ART"
            if [[ "$UNITY_ART" == *.tar.gz ]] || [[ "$UNITY_ART" == *.tgz ]]; then
              echo "Extracting Unity artifact into staging area"
              tar -xzf "$UNITY_ART" -C "$TMPDIR"
            else
              echo "Copying Unity artifact into staging area"
              mkdir -p "$TMPDIR/unity"
              cp "$UNITY_ART" "$TMPDIR/unity/"
            fi
          fi

          # If plugins archive exists, extract it and merge plugin files into staging
          if [ -n "${{ steps.plugins_archive.outputs.archive }}" ] && [ -f "${{ steps.plugins_archive.outputs.archive }}" ]; then
            PLUG_ARCH="${{ steps.plugins_archive.outputs.archive }}"
            echo "Found plugins archive: $PLUG_ARCH"
            mkdir -p "$TMPDIR/plugins_extract"
            if [[ "$PLUG_ARCH" == *.tar.gz ]] || [[ "$PLUG_ARCH" == *.tgz ]]; then
              tar -xzf "$PLUG_ARCH" -C "$TMPDIR/plugins_extract"
            else
              cp "$PLUG_ARCH" "$TMPDIR/plugins_extract/"
            fi
            # Copy any Plugins/ tree from the archive into staging root
            if [ -d "$TMPDIR/plugins_extract/Plugins" ]; then
              mkdir -p "$TMPDIR/Plugins"
              cp -a "$TMPDIR/plugins_extract/Plugins/." "$TMPDIR/Plugins/"
            fi
            # Also copy any Mods intended for StreamingAssets
            if [ -d "$TMPDIR/plugins_extract/Mods" ]; then
              mkdir -p "$TMPDIR/MateEngineX_Data/StreamingAssets/Mods"
              cp -a "$TMPDIR/plugins_extract/Mods/." "$TMPDIR/MateEngineX_Data/StreamingAssets/Mods/"
            fi
          fi

          # If the repo contains a local integration plugin copy it into both Plugins/ and StreamingAssets/Mods for runtime
          if [ -d "Plugins/Synthetic_Heart" ]; then
            echo "Including local Plugins/Synthetic_Heart into runtime layout"
            mkdir -p "$TMPDIR/Plugins/Synthetic_Heart"
            cp -a "Plugins/Synthetic_Heart/." "$TMPDIR/Plugins/Synthetic_Heart/"

            mkdir -p "$TMPDIR/MateEngineX_Data/StreamingAssets/Mods/Synthetic_Heart"
            cp -a "Plugins/Synthetic_Heart/." "$TMPDIR/MateEngineX_Data/StreamingAssets/Mods/Synthetic_Heart/"
          fi

          # Add essential metadata & helper files (README, LICENSE, launch.sh)
          mkdir -p "$TMPDIR/meta"
          for f in README.md LICENSE launch.sh; do
            if [ -f "$f" ]; then
              cp "$f" "$TMPDIR/meta/"
              echo "Included $f"
            fi
          done

          # If the extracted Unity artifact didn't produce an executable layout, include known runtime files if present in repo root
          for f in MateEngineX.x86_64 UnityPlayer.so launch.sh; do
            if [ -f "$f" ] && [ ! -f "$TMPDIR/$f" ]; then
              echo "Copying $f into staging"
              cp "$f" "$TMPDIR/"
            fi
          done

          # Finalize tarball
          tar -C "$TMPDIR" -czf "$OUT_NAME" .

          ls -lh "$OUT_NAME"
          echo "tarball=$OUT_NAME" >> $GITHUB_OUTPUT
          rm -rf "$TMPDIR"

      - name: Detect plugins archive
        id: plugins_archive
        run: |
          set -e
          OUT_DIR=dist
          if [ -d "$OUT_DIR" ]; then
            for f in "$OUT_DIR"/plugins-*.tar.gz; do
              if [ -f "$f" ]; then
                echo "Found plugins archive: $f"
                echo "archive=$f" >> $GITHUB_OUTPUT
                exit 0
              fi
            done
          fi
          echo "No plugins archive found"
          echo "archive=" >> $GITHUB_OUTPUT

      - name: Create GitHub release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.vars.outputs.TAG }}
          release_name: ${{ steps.vars.outputs.TAG }}
          body: "Release ${{ steps.vars.outputs.TAG }} created by workflow."
          draft: false
          prerelease: false

      - name: Upload Unity build artifact (if any)
        if: ${{ steps.package_unity.outputs.unity_build_artifact != '' }}
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ${{ steps.package_unity.outputs.unity_build_artifact }}
          asset_name: ${{ steps.package_unity.outputs.unity_build_artifact }}
          asset_content_type: application/gzip

      - name: Upload release asset (tarball)
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ${{ steps.package_release.outputs.tarball }}
          asset_name: ${{ steps.package_release.outputs.tarball }}
          asset_content_type: application/gzip

      - name: Upload plugins archive (if any)
        if: ${{ steps.plugins_archive.outputs.archive != '' }}
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ${{ steps.plugins_archive.outputs.archive }}
          asset_name: ${{ steps.plugins_archive.outputs.archive }}
          asset_content_type: application/gzip

      - name: Output release info
        run: |
          echo "Release created: tag=${{ steps.vars.outputs.TAG }}"
          echo "Asset: ${{ steps.package_release.outputs.tarball }}"
