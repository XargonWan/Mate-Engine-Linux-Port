name: Create Linux Release

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**/*.md'
      - 'README'
      - 'README.*'
      - 'LICENSE'
      - 'LICENSE.*'
      - '.gitignore'
      - '.gitattributes'
      - '.editorconfig'
      - 'docs/**'
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g. 1.2.3)'
        required: false
      tag:
        description: 'Git tag to create (if empty use v{version})'
        required: false
      unity_version:
        description: 'Unity Editor version to use for CI (e.g. 2021.3.31f1). Required for building MateEngineX.'
        required: false
        default: 'auto'
      simulate:
        description: 'If true, run in simulation mode: skip Unity builds and create mock artifacts.'
        required: false
        type: boolean
        default: false

permissions:
  contents: write

jobs:
  build_and_release:
    name: Build and create release
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up variables
        id: vars
        run: |
          VERSION=${{ github.event.inputs.version }}
          TAG=${{ github.event.inputs.tag }}
          UNITY_VERSION=${{ github.event.inputs.unity_version }}

          if [ -z "$VERSION" ]; then
            VERSION=$(git rev-parse --short=7 HEAD)
          fi
          if [ -z "$TAG" ]; then TAG="v${VERSION}"; fi
          if [ -z "$UNITY_VERSION" ]; then UNITY_VERSION="auto"; fi
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "TAG=$TAG" >> $GITHUB_OUTPUT
          echo "UNITY_VERSION=$UNITY_VERSION" >> $GITHUB_OUTPUT

      - name: Check Unity license secrets
        run: |
          # Ensure we have either UNITY_LICENSE or UNITY_SERIAL+UNITY_EMAIL+UNITY_PASSWORD
          if [ -n "${{ secrets.UNITY_SERIAL }}" ] && [ -n "${{ secrets.UNITY_EMAIL }}" ] && [ -n "${{ secrets.UNITY_PASSWORD }}" ]; then
            echo "UNITY_SERIAL credentials found; will use serial activation."
            exit 0
          fi
          if [ -n "${{ secrets.UNITY_LICENSE }}" ]; then
            echo "UNITY_LICENSE found; will use license file activation."
            exit 0
          fi
          echo "Unity license secrets are missing. Provide either UNITY_LICENSE or UNITY_SERIAL + UNITY_EMAIL + UNITY_PASSWORD."
          exit 1

      - name: Run build
        if: ${{ github.event.inputs.simulate != 'true' }}
        run: |
          set -e
          if [ -x ./build.sh ]; then
            echo "Running ./build.sh"
            ./build.sh
          elif [ -x ./scripts/build.sh ]; then
            echo "Running ./scripts/build.sh"
            ./scripts/build.sh
          else
            echo "No build script found; skipping build"
          fi

      - name: Build Unity project
        if: ${{ github.event.inputs.simulate != 'true' }}
        uses: game-ci/unity-builder@v4
        with:
          unityVersion: ${{ steps.vars.outputs.UNITY_VERSION }}
          projectPath: .
          targetPlatform: StandaloneLinux64
          buildName: MateEngineX
          buildsPath: build/unity
        env:
          UNITY_LICENSE: ${{ secrets.UNITY_LICENSE }}
          UNITY_SERIAL: ${{ secrets.UNITY_SERIAL }}
          UNITY_EMAIL: ${{ secrets.UNITY_EMAIL }}
          UNITY_PASSWORD: ${{ secrets.UNITY_PASSWORD }}

      - name: Package Unity build artifacts
        if: ${{ github.event.inputs.simulate != 'true' }}
        id: package_unity
        run: |
          set -e
          BUILD_DIR=build/unity
          if [ -d "$BUILD_DIR" ]; then
            OUT="mate-engine-unity-${{ steps.vars.outputs.VERSION }}.tar.gz"
            echo "Packaging Unity build from $BUILD_DIR -> $OUT"
            tar -C "$BUILD_DIR" -czf "$OUT" .
            ls -lh "$OUT"
            echo "unity_build_artifact=$OUT" >> $GITHUB_OUTPUT
          else
            echo "No Unity build artifacts found in $BUILD_DIR"; exit 2
          fi

      - name: Create mock Unity build artifact (simulate mode)
        id: package_unity_sim
        if: ${{ github.event.inputs.simulate == 'true' }}
        run: |
          set -euxo pipefail
          OUT="mate-engine-unity-${{ steps.vars.outputs.VERSION }}.tar.gz"
          echo "Creating mock Unity build artifact $OUT"
          TMPDIR=$(mktemp -d)
          mkdir -p "$TMPDIR"/unity
          echo "Mock Unity build for $OUT" > "$TMPDIR"/unity/README.txt
          tar -C "$TMPDIR"/unity -czf "$OUT" .
          ls -lh "$OUT"
          echo "unity_build_artifact=$OUT" >> $GITHUB_OUTPUT

      - name: Build plugins package
        if: ${{ github.event.inputs.simulate != 'true' }}
        run: |
          set -e
          if [ -x ./scripts/build_plugins.sh ]; then
            ./scripts/build_plugins.sh
          else
            echo "No plugins build script found; skipping"
          fi

      - name: Detect plugins archive
        id: plugins_archive
        run: |
          set -e
          OUT_DIR=dist
          if [ -d "$OUT_DIR" ]; then
            for f in "$OUT_DIR"/plugins-*.tar.gz; do
              if [ -f "$f" ]; then
                echo "Found plugins archive: $f"
                echo "archive=$f" >> $GITHUB_OUTPUT
                exit 0
              fi
            done
          fi
          echo "No plugins archive found"
          echo "archive=" >> $GITHUB_OUTPUT

      - name: Create release tarball
        id: package_release
        run: |
          set -euo pipefail
          OUT_NAME="MateEngineX_${{ steps.vars.outputs.VERSION }}.tar.gz"
          echo "Creating release tarball $OUT_NAME containing runtime artifacts and integration marker"

          TMPDIR=$(mktemp -d)
          echo "Staging in $TMPDIR"

          # If the Unity build artifact exists and looks like a tar, extract it to preserve runtime layout
          UNITY_ART="${{ steps.package_unity.outputs.unity_build_artifact }}"
          if [ -z "$UNITY_ART" ] && [ -n "${{ steps.package_unity_sim.outputs.unity_build_artifact }}" ]; then
            UNITY_ART="${{ steps.package_unity_sim.outputs.unity_build_artifact }}"
          fi
          if [ -n "$UNITY_ART" ] && [ -f "$UNITY_ART" ]; then
            echo "Found Unity artifact: $UNITY_ART"
            if [[ "$UNITY_ART" == *.tar.gz ]] || [[ "$UNITY_ART" == *.tgz ]]; then
              echo "Extracting Unity artifact into staging area"
              tar -xzf "$UNITY_ART" -C "$TMPDIR"
            else
              echo "Copying Unity artifact into staging area"
              mkdir -p "$TMPDIR/unity"
              cp "$UNITY_ART" "$TMPDIR/unity/"
            fi
          fi

          # Normalize staging layout to match official runtime structure
          # If the Unity build is nested under StandaloneLinux64 (or a single top folder), flatten it.
          if [ -d "$TMPDIR/StandaloneLinux64" ] && [ ! -d "$TMPDIR/MateEngineX_Data" ]; then
            echo "Flattening StandaloneLinux64 into staging root"
            cp -a "$TMPDIR/StandaloneLinux64/." "$TMPDIR/"
            rm -rf "$TMPDIR/StandaloneLinux64"
          fi
          TOP_DIR_COUNT=$(find "$TMPDIR" -mindepth 1 -maxdepth 1 -type d | wc -l | tr -d ' ')
          if [ "$TOP_DIR_COUNT" = "1" ] && [ ! -d "$TMPDIR/MateEngineX_Data" ]; then
            TOP_DIR=$(find "$TMPDIR" -mindepth 1 -maxdepth 1 -type d | head -n 1)
            if [ -d "$TOP_DIR" ]; then
              echo "Flattening top-level folder $(basename "$TOP_DIR") into staging root"
              cp -a "$TOP_DIR/." "$TMPDIR/"
              rm -rf "$TOP_DIR"
            fi
          fi

          # If plugins archive exists, extract it and merge plugin files into staging
          if [ -n "${{ steps.plugins_archive.outputs.archive }}" ] && [ -f "${{ steps.plugins_archive.outputs.archive }}" ]; then
            PLUG_ARCH="${{ steps.plugins_archive.outputs.archive }}"
            echo "Found plugins archive: $PLUG_ARCH"
            mkdir -p "$TMPDIR/plugins_extract"
            if [[ "$PLUG_ARCH" == *.tar.gz ]] || [[ "$PLUG_ARCH" == *.tgz ]]; then
              tar -xzf "$PLUG_ARCH" -C "$TMPDIR/plugins_extract"
            else
              cp "$PLUG_ARCH" "$TMPDIR/plugins_extract/"
            fi
            # Copy any Plugins/ tree from the archive into staging root
            if [ -d "$TMPDIR/plugins_extract/Plugins" ]; then
              mkdir -p "$TMPDIR/Plugins"
              cp -a "$TMPDIR/plugins_extract/Plugins/." "$TMPDIR/Plugins/"
            fi
            # Also copy any Mods intended for StreamingAssets
            if [ -d "$TMPDIR/plugins_extract/Mods" ]; then
              mkdir -p "$TMPDIR/MateEngineX_Data/StreamingAssets/Mods"
              cp -a "$TMPDIR/plugins_extract/Mods/." "$TMPDIR/MateEngineX_Data/StreamingAssets/Mods/"
            fi
          fi

          # Do not ship Synthetic_Heart plugin source files; integration is compiled into the build.

          # If the extracted Unity artifact didn't produce an executable layout, include known runtime files if present in repo root
          for f in MateEngineX.x86_64 UnityPlayer.so launch.sh; do
            if [ -f "$f" ] && [ ! -f "$TMPDIR/$f" ]; then
              echo "Copying $f into staging"
              cp "$f" "$TMPDIR/"
            fi
          done

          # Normalize executable name to match launcher expectations (MateEngineX.x86_64)
          if [ ! -f "$TMPDIR/MateEngineX.x86_64" ] && [ -f "$TMPDIR/MateEngineX" ]; then
            echo "Renaming MateEngineX -> MateEngineX.x86_64"
            mv "$TMPDIR/MateEngineX" "$TMPDIR/MateEngineX.x86_64"
          fi

          # Exclude debug-only folder from release
          if [ -d "$TMPDIR/MateEngineX_BurstDebugInformation_DoNotShip" ]; then
            echo "Removing MateEngineX_BurstDebugInformation_DoNotShip from staging"
            rm -rf "$TMPDIR/MateEngineX_BurstDebugInformation_DoNotShip"
          fi

          # Include Synthetic Heart marker so the overlay is enabled by default (user can delete to remove)
          SYNTH_DIR="$TMPDIR/MateEngineX_Data/StreamingAssets/Mods/SyntheticHeart"
          mkdir -p "$SYNTH_DIR"
          cat > "$SYNTH_DIR/enabled.json" <<'EOF'
          {"enabled": true, "name": "Synthetic Heart"}
          EOF
          cat > "$SYNTH_DIR/README.txt" <<'EOF'
          Synthetic Heart integration is enabled by default.
          Remove this folder to disable the overlay and menu entry.
          EOF

          # Validate required runtime layout
          if [ ! -f "$TMPDIR/MateEngineX.x86_64" ]; then
            echo "ERROR: Missing MateEngineX.x86_64 in staging. Unity build artifact did not provide the executable."
            exit 3
          fi
          if [ ! -d "$TMPDIR/MateEngineX_Data" ]; then
            echo "ERROR: Missing MateEngineX_Data in staging. Unity build artifact did not provide runtime data."
            exit 4
          fi

          # Finalize tarball
          tar -C "$TMPDIR" -czf "$OUT_NAME" .

          ls -lh "$OUT_NAME"
          echo "tarball=$OUT_NAME" >> $GITHUB_OUTPUT
          rm -rf "$TMPDIR"

      - name: Prepare release metadata
        id: release_meta
        run: |
          set -euo pipefail
          VER=${{ steps.vars.outputs.VERSION }}
          TITLE="Public Release ${VER}"
          TMPBODY=$(mktemp)
          printf '%s\n' \
            "Public Release ${VER}" \
            "" \
            "This is a the release ${VER} of MateEngine Linux Port." \
            "" \
            "How to use:" \
            "" \
            "    - Download MateEngineX_${VER}.tar.gz" \
            "    - Extract it using your favourite decompression utility" \
            "    - Set \`launch.sh\` as executable: \`chmod +x launch.sh\`" \
            "    - Double click the launcher or run it from terminal: \`./launch.sh\`" \
            "    - Enjoy!" > "$TMPBODY"
          echo "title=$TITLE" >> $GITHUB_OUTPUT
          echo "body<<EOF" >> $GITHUB_OUTPUT
          cat "$TMPBODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          rm -f "$TMPBODY"

      - name: Select unity artifact (supports simulation)
        id: select_unity_artifact
        run: |
          if [ -n "${{ steps.package_unity.outputs.unity_build_artifact }}" ]; then
            echo "unity_artifact=${{ steps.package_unity.outputs.unity_build_artifact }}" >> $GITHUB_OUTPUT
          elif [ -n "${{ steps.package_unity_sim.outputs.unity_build_artifact }}" ]; then
            echo "unity_artifact=${{ steps.package_unity_sim.outputs.unity_build_artifact }}" >> $GITHUB_OUTPUT
          else
            echo "unity_artifact=" >> $GITHUB_OUTPUT
          fi

      - name: Publish release
        id: publish_release
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ steps.vars.outputs.TAG }}
          name: ${{ steps.release_meta.outputs.title }}
          body: ${{ steps.release_meta.outputs.body }}
          artifacts: |
            MateEngineX_*.tar.gz
          allowUpdates: true
          omitBodyDuringUpdate: true
          makeLatest: true
          draft: false
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Output release info
        run: |
          echo "Release created: tag=${{ steps.vars.outputs.TAG }}"
          echo "Asset: ${{ steps.package_release.outputs.tarball }}"
